import boto3
import json
import time
import pytest
import uuid
from datetime import datetime

# --- CONFIGURATION ---
# You can get these from CloudFormation Outputs or your own knowledge.
# For a fully automated approach, you could fetch outputs via boto3.
IOT_TOPIC = "home/heating/status"
REGION = "eu-west-2" # <--- IMPORTANT: Update this to your Stack's region (e.g., us-east-1, eu-central-1)

@pytest.mark.e2e
def test_end_to_end_data_flow():
    """
    End-to-End (E2E) Test using REAL Cloud Infrastructure.
    
    Flow:
    1. Simulates a device sending a payload to AWS IoT Core (via HTTP API).
    2. Waits for the cloud pipeline to process the message.
    3. Verifies that the data persisted correctly in DynamoDB.
    """
    
    # 1. Initialize Clients
    # Note: The local machine must be authenticated (e.g., 'aws sso login' or env vars)
    iot_data = boto3.client('iot-data', region_name=REGION)
    dynamodb = boto3.resource('dynamodb', region_name=REGION)
    client_ddb = boto3.client('dynamodb', region_name=REGION)
    
    # Dynamically find the exact table name (looking for "HeatingEvents")
    # This avoids hardcoding the random suffix generated by CDK.
    tables = client_ddb.list_tables()
    real_table_name = next((t for t in tables['TableNames'] if 'HeatingEvents' in t), None)
    
    if not real_table_name:
        pytest.fail("‚ùå DynamoDB table not found in the cloud! Did you deploy the stack?")
        
    print(f"\nüåç Target Table identified: {real_table_name}")
    table = dynamodb.Table(real_table_name)

    # 2. Generate Test Data
    test_id = f"e2e-test-{uuid.uuid4().hex[:8]}"
    timestamp = int(time.time())
    
    payload = {
        "device_id": test_id,
        "timestamp": timestamp,
        "status": "TESTING",
        "sensor_voltage": 999,
        "metadata": {
            "source": "e2e-test-runner",
            "reason": "integration-check"
        }
    }

    # 3. Publish to IoT Core
    print(f"üì° Sending message to topic '{IOT_TOPIC}'...")
    try:
        iot_data.publish(
            topic=IOT_TOPIC,
            qos=1,
            payload=json.dumps(payload)
        )
    except Exception as e:
        pytest.fail(f"‚ùå Failed to publish to IoT Core. Check permissions/region. Error: {e}")

    # 4. Wait for Ingestion
    # We wait because the architecture is asynchronous (IoT Rule -> DynamoDB)
    print("‚è≥ Waiting 5 seconds for cloud processing...")
    time.sleep(5)

    # 5. Verify in DynamoDB
    # Fetch the item using the Partition Key and Sort Key
    response = table.get_item(
        Key={
            'device_id': test_id,
            'timestamp': timestamp
        }
    )

    # Assertions
    if 'Item' not in response:
        pytest.fail(f"‚ùå Data did not appear in DynamoDB! Checked Key: {test_id} / {timestamp}")

    item = response['Item']
    print(f"‚úÖ Data successfully found in DynamoDB: {item}")
    
    # Verify Data Integrity
    assert item['device_id'] == test_id
    assert item['status'] == "TESTING"
    assert item['metadata']['source'] == "e2e-test-runner"
    
    # Optional: Cleanup (Delete the test data to keep the table clean)
    table.delete_item(Key={'device_id': test_id, 'timestamp': timestamp})
    print("üßπ Test data cleaned up.")